import numpy as np
from scipy.stats import t
import matplotlib.pyplot as plt
import pandas as pd

# Путь к файлу с исходными данными
data_file_path = 'Статистика.txt'


def pearson_correlation(x, y):
    # Находим средние значения для x и y
    mean_x = np.mean(x)
    mean_y = np.mean(y)

    # Вычисляем числитель (сумма произведений отклонений)
    numerator = np.sum((x - mean_x) * (y - mean_y))

    # Вычисляем знаменатель (произведение корней квадратов сумм квадратов отклонений)
    denominator = np.sqrt(np.sum((x - mean_x) ** 2) * np.sum((y - mean_y) ** 2))

    # Возвращаем коэффициент корреляции Пирсона
    return numerator / denominator if denominator != 0 else 0


print('ЗАДАНИЕ 1')
# ЗАДАНИЕ 1
# Считываем данные из файла и создаем списки age и crimes
with open(data_file_path, 'r') as file:
    element = list(map(int, file.readlines()))

# Сортировка и расчет частоты для каждого возраста
element.sort()
age = [i for i in range(14, 74) if i not in [68, 72]]  # Возрастной диапазон от 14 до 73, исключая 68 и 72
crimes = [element.count(i) for i in age]

# Преобразование списков в массивы для дальнейшего анализа
ages = np.array(age)
frequencies = np.array(crimes)

# Ручной расчет коэффициента корреляции Пирсона
correlation_coefficient = pearson_correlation(ages, frequencies)
print("Коэффициент линейной корреляции между возрастом и частотой преступлений:", correlation_coefficient)

# Комментарий:
# Коэффициент корреляции -0.577 указывает на умеренную отрицательную связь между возрастом и частотой преступлений.
# Это значит, что с увеличением возраста частота преступлений уменьшается.
# Однако этот коэффициент показывает только линейную зависимость, поэтому он не учитывает возможных нелинейных связей.

#должно получиться -0.5777

print('')
print('')
print('ЗАДАНИЕ 2')

# Число наблюдений
n = len(ages)

# Расчет t-статистики для проверки значимости корреляции
t_statistic = correlation_coefficient * np.sqrt((n - 2) / (1 - correlation_coefficient ** 2))

# Определение t-критического для двустороннего теста с уровнем значимости alpha
alpha = 0.05
t_critical = t.ppf(1 - alpha / 2, df=n - 2)  # Двусторонний тест, поэтому alpha/2

# Вывод результатов
print("t-статистика:", t_statistic)
print("t-критическое значение:", t_critical)

# Оценка значимости на основе сравнения по модулю
if abs(t_statistic) > t_critical:
    print("Коэффициент корреляции значим на уровне 0.05.")
else:
    print("Коэффициент корреляции не значим на уровне 0.05.")


# Комментарий:
# При уровне значимости 0.05 p-value оказался ниже 0.05, что позволяет отвергнуть нулевую гипотезу об отсутствии корреляции.
# Это означает, что коэффициент корреляции статистически значим, и мы можем уверенно говорить о наличии линейной связи.

# -5.296
#вывести не п значение, а т критическое и провести сравнение больше меньше по модулю, основной принцип проверки гипотез

# print('')
# print('')
# print('ЗАДАНИЕ 3 - на графике')# завершена
#
# # Построение корреляционного поля
# plt.scatter(ages, frequencies, color='orange', label='Данные')
#
# # Добавление трендовой линии
# z = np.polyfit(ages, frequencies, 1)  # Параметры для линейной регрессии
# p = np.poly1d(z)
# plt.plot(ages, p(ages), color='blue', linestyle='--', label='Линия тренда')
#
# plt.title('Корреляционное поле: Возраст преступника vs Частота преступлений')
# plt.xlabel('Возраст преступника')
# plt.ylabel('Частота преступлений')
# plt.legend()
# plt.grid(True)
# plt.show()

# # Комментарий:
# # График корреляционного поля с добавленной трендовой линией визуализирует связь между возрастом и частотой преступлений.
# # Линия тренда показывает, что частота преступлений уменьшается с возрастом, подтверждая отрицательную корреляцию.


print('')
print('')
print('ЗАДАНИЕ 4')

# Загрузка данных
file_path = "Статистика.txt"
with open(file_path, 'r') as file:
    element = [int(line.strip()) for line in file]

# Создаем DataFrame для возрастных данных
# Этот DataFrame содержит столбец 'Age', в котором перечислены возрастные данные преступников.
ages_df = pd.DataFrame(element, columns=["Age"])

# Определяем интервалы возрастов с шагом 9
# Создаем массив 'bins' с интервалами возрастов, начиная с минимального значения возраста до максимального значения возраста, добавляя 9 к каждому следующему значению.
# np.arange генерирует последовательность значений с шагом 9.
bins = np.arange(ages_df["Age"].min(), ages_df["Age"].max() + 9, 9)

# Создаем текстовые метки для каждого интервала
# 'labels' хранит строки, представляющие диапазоны возрастов, например, '14-22', '23-31'.
# Мы проходим по интервалам в 'bins' и формируем метку для каждого интервала, указывая начальное и конечное значения.
labels = [f'{int(bins[i])}-{int(bins[i + 1]) - 1}' for i in range(len(bins) - 1)]

# Настройка последнего интервала
# Уточняем последний интервал вручную, чтобы он имел корректное текстовое представление.
labels[-1] = f'{int(bins[-2])}-{int(bins[-1]) - 1}'

# Группировка данных по интервалам
# Используем pd.cut для разбиения столбца 'Age' по заданным интервалам (bins).
# Присваиваем каждому значению возраста соответствующую группу (интервал) из 'labels'.
# Параметр include_lowest=True означает, что граница слева включена в каждый интервал.
ages_df['Age Group'] = pd.cut(ages_df['Age'], bins=bins - 1, labels=labels, include_lowest=True)

# Подсчет количества преступников в каждом возрастном интервале
# Считаем количество значений в каждом интервале (то есть количество преступников для каждого возрастного интервала).
age_group_counts = ages_df['Age Group'].value_counts(sort=False)

# Общее среднее значение возраста
# Вычисляем среднее значение возраста по всем данным, которое будет использоваться для межгрупповой дисперсии.
mean_value = ages_df['Age'].mean()

# Средний возраст в каждой группе и количество в группе
# grouped_age_sums: суммируем возрастные значения внутри каждой возрастной группы.
grouped_age_sums = ages_df.groupby('Age Group', observed=True)['Age'].sum()
# grouped_counts: считаем количество преступников в каждой возрастной группе.
grouped_counts = ages_df.groupby('Age Group', observed=True)['Age'].count()
# grouped_means: вычисляем средний возраст в каждой возрастной группе.
grouped_means = grouped_age_sums / grouped_counts

# Внутригрупповая дисперсия
# Для каждой возрастной группы вычисляем дисперсию (измерение разброса возрастов относительно среднего в этой группе).
# lambda x: применяется к каждой группе и вычисляет сумму квадратов отклонений возрастов от среднего в группе.
# Делим на размер группы - 1 (несмещенная оценка).
grouped_variances = ages_df.groupby('Age Group', observed=True).apply(
    lambda x: np.sum((x['Age'] - grouped_means.loc[x['Age Group'].iloc[0]]) ** 2) / (x.shape[0] - 1)
)

# Взвешиваем внутригрупповую дисперсию по количеству преступников в каждой группе и делим на общее количество данных
inside_group = sum(grouped_variances * age_group_counts / age_group_counts.sum())

# Межгрупповая дисперсия
# Вычисляем межгрупповую дисперсию, которая оценивает, как средние возрастные значения в группах отличаются от общего среднего по всем данным.
outside_group = sum(((grouped_means - mean_value) ** 2) * age_group_counts / age_group_counts.sum())
print(outside_group)

# Общая дисперсия и корреляционное отношение
# Общая дисперсия является суммой внутригрупповой и межгрупповой дисперсий.
com_variances = inside_group + outside_group
print(com_variances)
# Корреляционное отношение (η) вычисляется как квадратный корень из отношения межгрупповой дисперсии к общей дисперсии.
n_var = (outside_group / com_variances) ** 0.5

# Вывод корреляционного отношения
print("Корреляционное отношение:", n_var)